---
title: "Thoughts #001"
description: "Reverse Polish Lisp"
pubDatetime: 2025-07-28T03:00:00Z
tags:
  - thoughts
draft: false
slug: "thoughts-001"
---

This one's a funny one. Over on the Neorg discord we began discussing tools like qalc and numbat -- this quickly derailed into a conversation about notation.
One of qalc's niceities is that you can write in it using Reverse Polish Notation.

The amazing thing about RPN is that it works like a stack, meaning that you can omit brackets in almost all cases: `2 4 * 2 2 + /` equals `2`.
This obviously led me down a chain of thoughts leading to a climax - the concept of using this in programming languages.

Online, I see a single attempt called Reverse Polish Lisp (name goes hard), but other than that I haven't seen this attempt be seriously tested. I know
RPN is a little unintuitive, but it's no less unintuitive than lisps forward notation: `(+ 3 4)`.

Extending this further, FP languages often do the `func param1 param2` syntax, meaning you need to use quite a lot of brackets for nested operations like `func (other_func a) (other_other_func b)`. The pipe operator usually
alleviates these problems, but maybe it could be remedied altogether with a `param1 param2 func` approach? I don't even feel it'd be hard for GLR parsers to figure
this syntax out, it wouldn't take much branching.

Furthermore, I realized that you might *never* need brackets with this approach. If you know the arities of each function (which a compiler does), then you should be able to create a deterministic algorithm
that perfectly disambiguates various complex cases like:

```
3 4 add 6 mult 3 div <-> add 3 4 |> mult 6 |> div 3
```

...without ever being ambiguous. Surely someone has done so before, but in my surface level research on "esoteric disambiguation algorithms for uncommonly used programming languages", I didn't find anything :p

Is the idea weird? Yes. Is it cool? Yes. I like both of those things. Why don't we inject more RPN into our lives?
